// Generated by CoffeeScript 1.6.3
var RayTracer;

RayTracer = (function() {
  function RayTracer(color, pixelX, pixelY, scene) {
    this.color = color;
    this.pixelX = pixelX;
    this.pixelY = pixelY;
    this.scene = scene;
  }

  RayTracer.prototype.trace = function() {
    var averageColorVector, colors, rays, traceRay,
      _this = this;
    rays = this.castRays(RayConfig.antialiasing);
    traceRay = function(ray) {
      return _this.traceRec(ray, new Color(0, 0, 0), RayConfig.recDepth);
    };
    colors = rays.map(function(ray) {
      return traceRay(ray);
    });
    averageColorVector = colors.map(function(c) {
      return c.toVector();
    }).reduce(function(previous, current) {
      return previous.add(current);
    }).multiply(1 / colors.length);
    return this.color.setElements(averageColorVector.elements);
  };

  RayTracer.prototype.traceRec = function(ray, color, times) {
    var globalAmbient, globalAmbientColor, intersection, light, obj, pos, _i, _len, _ref;
    intersection = this.scene.firstIntersection(ray);
    if (intersection) {
      pos = intersection[0];
      obj = intersection[1];
      globalAmbient = this.scene.globalAmbient;
      globalAmbientColor = obj.reflectionProperties.ambientColor.multiply(globalAmbient);
      color = color.add(globalAmbientColor);
      if (RayConfig.illumination) {
        _ref = this.scene.lights;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          light = _ref[_i];
          color = color.add(this.illuminate(pos, obj, ray, light));
        }
      }
      if (times <= 0) {
        return color;
      }
      if (RayConfig.reflection) {
        color = color.add(this.reflectAndRefract(pos, obj, ray, times));
      }
    }
    return color;
  };

  RayTracer.prototype.reflectAndRefract = function(pos, obj, ray, times) {
    var color, reflectPower, reflectedColor, reflectedRay, refractPower, refractedColor, refractedRay, specularReflection, specularRefraction, _ref;
    _ref = this.specularRays(pos, obj, ray), reflectedRay = _ref[0], refractedRay = _ref[1], reflectPower = _ref[2], refractPower = _ref[3];
    color = new Color(0, 0, 0);
    specularReflection = new Color(0, 0, 0);
    specularRefraction = new Color(0, 0, 0);
    if (reflectedRay != null) {
      reflectedColor = this.traceRec(reflectedRay, color, times - 1);
      specularReflection = reflectedColor.multiplyColor(obj.reflectionProperties.specularColor);
      color = color.add(specularReflection.multiply(reflectPower));
    }
    if (refractedRay != null) {
      refractedColor = this.traceRec(refractedRay, color, times - 1);
      specularRefraction = refractedColor.multiplyColor(obj.reflectionProperties.specularColor);
      color = color.add(specularRefraction.multiply(refractPower));
    }
    return color;
  };

  RayTracer.prototype.specularRays = function(pos, obj, ray) {
    var cos1, cos2, first, inside, n1, n2, nv, p_reflect, p_refract, ref, reflectPower, reflectedRay, refractPower, refractedRay, underRoot, w, w_dot_nv, wr, wt;
    inside = ray.refraction !== 1;
    nv = obj.norm(pos);
    if (inside) {
      nv = nv.multiply(-1);
    }
    w = pos.subtract(ray.line.anchor).toUnitVector();
    w_dot_nv = w.dot(nv);
    wr = nv.multiply(2 * w_dot_nv).subtract(w).toUnitVector().multiply(-1);
    reflectedRay = new Ray($L(pos, wr), ray.refraction, ray.power);
    if (wr.elements[0] === 0 && wr.elements[0] === 0 && wr.elements[0] === 0) {
      reflectedRay = null;
    }
    refractedRay = null;
    n1 = ray.refraction;
    n2 = (inside ? 1 : obj.reflectionProperties.refractionIndex);
    ref = n1 / n2;
    reflectPower = 1;
    refractPower = 0;
    if (n2 !== Infinity) {
      first = w.subtract(nv.multiply(w_dot_nv)).multiply(-ref);
      underRoot = 1 - (ref * ref) * (1 - (w_dot_nv * w_dot_nv));
      if (underRoot >= 0) {
        wt = first.subtract(nv.multiply(Math.sqrt(underRoot))).toUnitVector();
        refractedRay = new Ray($L(pos, wt), n2, ray.power);
        cos1 = wr.dot(nv);
        cos2 = wt.dot(nv.multiply(-1));
        p_reflect = (n2 * cos1 - n1 * cos2) / (n2 * cos1 + n1 * cos2);
        p_refract = (n1 * cos1 - n2 * cos2) / (n1 * cos1 + n2 * cos2);
        reflectPower = 0.5 * (p_reflect * p_reflect + p_refract * p_refract);
        refractPower = 1 - reflectPower;
      }
    }
    return [reflectedRay, refractedRay, reflectPower, refractPower];
  };

  RayTracer.prototype.illuminate = function(pos, obj, ray, light) {
    var E, ambient, ambientColor, diffuse, frac, kd, ks, n, nv, specularHighlights, spepcularIntensity, w, wl, wr;
    nv = obj.norm(pos);
    w = ray.line.direction;
    wl = light.location.subtract(pos).toUnitVector();
    wr = nv.multiply(2).multiply(w.dot(nv)).subtract(w).toUnitVector();
    if (this.scene.intersections(new Ray($L(pos, wl), ray.refraction, 1)).length > 0) {
      return new Color(0, 0, 0);
    }
    ambient = light.intensity.ambient;
    ambientColor = obj.reflectionProperties.ambientColor.multiply(ambient);
    kd = obj.reflectionProperties.diffuseColor;
    E = light.intensity.diffuse * nv.dot(wl);
    diffuse = kd.multiply(E * light.intensity.diffuse);
    n = obj.reflectionProperties.specularExponent;
    ks = obj.reflectionProperties.specularColor;
    frac = Math.pow(wr.dot(wl), n) / nv.dot(wl);
    spepcularIntensity = frac * E;
    if (frac < 0) {
      spepcularIntensity = 0;
    }
    specularHighlights = ks.multiply(spepcularIntensity);
    return ambientColor.add(diffuse).add(specularHighlights);
  };

  RayTracer.prototype.castRays = function(antialiasing) {
    var camera, h, w, _i, _results,
      _this = this;
    camera = this.scene.camera;
    w = camera.width * antialiasing;
    h = camera.height * antialiasing;
    return (function() {
      _results = [];
      for (var _i = 1; 1 <= antialiasing ? _i <= antialiasing : _i >= antialiasing; 1 <= antialiasing ? _i++ : _i--){ _results.push(_i); }
      return _results;
    }).apply(this).map(function(i) {
      var _i, _results;
      return (function() {
        _results = [];
        for (var _i = 1; 1 <= antialiasing ? _i <= antialiasing : _i >= antialiasing; 1 <= antialiasing ? _i++ : _i--){ _results.push(_i); }
        return _results;
      }).apply(this).map(function(j) {
        var centerPixelX, centerPixelY, rayDirection;
        centerPixelX = (_this.pixelX * antialiasing + (i - 1) + 0.5 - w / 2) / h * camera.imagePaneHeight;
        centerPixelY = (-_this.pixelY * antialiasing - (j - 1) - 0.5 + h / 2) / w * camera.imagePaneWidth;
        rayDirection = camera.imageCenter.add(camera.upDirection.multiply(centerPixelX)).add(camera.rightDirection.multiply(centerPixelY)).subtract(camera.position);
        return new Ray($L(camera.position, rayDirection), 1, 1);
      });
    }).reduce(function(a, b) {
      return a.concat(b);
    });
  };

  return RayTracer;

})();
