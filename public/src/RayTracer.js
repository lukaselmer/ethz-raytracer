// Generated by CoffeeScript 1.6.3
var RayTracer;

RayTracer = (function() {
  function RayTracer(color, pixelX, pixelY, scene) {
    this.color = color;
    this.pixelX = pixelX;
    this.pixelY = pixelY;
    this.scene = scene;
  }

  RayTracer.prototype.trace = function() {
    var averageColorVector, colors, rays, traceRay,
      _this = this;
    rays = this.castRays(RayConfig.antialiasing);
    traceRay = function(ray) {
      return _this.traceRec(ray, new Color(0, 0, 0), RayConfig.recDepth);
    };
    colors = rays.map(function(ray) {
      return traceRay(ray);
    });
    averageColorVector = colors.map(function(c) {
      return c.toVector();
    }).reduce(function(previous, current) {
      return previous.add(current);
    }).multiply(1 / colors.length);
    return this.color.setElements(averageColorVector.elements);
  };

  RayTracer.prototype.traceRec = function(ray, color, times) {
    var globalAmbient, globalAmbientColor, intersection, light, obj, pos, _i, _len, _ref;
    intersection = this.scene.firstIntersection(ray);
    if (intersection) {
      pos = intersection[0];
      obj = intersection[1];
      globalAmbient = this.scene.globalAmbient;
      globalAmbientColor = obj.reflectionProperties.ambientColor.multiply(globalAmbient);
      color = color.add(globalAmbientColor);
      if (RayConfig.illumination) {
        _ref = this.scene.lights;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          light = _ref[_i];
          color = color.add(this.illuminate(pos, obj, ray, light));
        }
      }
      if (times <= 0) {
        return color;
      }
      if (RayConfig.reflection) {
        color = color.add(this.reflect_and_refract(pos, obj, ray, times));
      }
    }
    return color;
  };

  RayTracer.prototype.reflect_and_refract = function(pos, obj, ray, times) {
    var ks, nv, specularReflection, w, wr;
    nv = obj.norm(pos);
    w = ray.line.direction;
    wr = nv.multiply(2 * w.dot(nv)).subtract(w).toUnitVector().multiply(-1);
    ks = obj.reflectionProperties.specularColor;
    specularReflection = this.traceRec(new Ray($L(pos, wr), ray.rafraction, 1), new Color(0, 0, 0), times - 1);
    specularReflection = specularReflection.multiplyColor(ks);
    return specularReflection;
  };

  RayTracer.prototype.illuminate = function(pos, obj, ray, light) {
    var E, ambient, ambientColor, diffuse, frac, kd, ks, n, nv, specularHighlights, spepcularIntensity, w, wl, wr;
    nv = obj.norm(pos);
    w = ray.line.direction;
    wl = light.location.subtract(pos).toUnitVector();
    wr = nv.multiply(2).multiply(w.dot(nv)).subtract(w).toUnitVector();
    if (this.scene.intersections(new Ray($L(pos, wl), ray.refraction, 1)).length > 0) {
      return new Color(0, 0, 0);
    }
    ambient = light.intensity.ambient;
    ambientColor = obj.reflectionProperties.ambientColor.multiply(ambient);
    kd = obj.reflectionProperties.diffuseColor;
    E = light.intensity.diffuse * nv.dot(wl);
    diffuse = kd.multiply(E * light.intensity.diffuse);
    n = obj.reflectionProperties.specularExponent;
    ks = obj.reflectionProperties.specularColor;
    frac = Math.pow(wr.dot(wl), n) / nv.dot(wl);
    spepcularIntensity = frac * E;
    if (frac < 0) {
      spepcularIntensity = 0;
    }
    specularHighlights = ks.multiply(spepcularIntensity);
    return ambientColor.add(diffuse).add(specularHighlights);
  };

  RayTracer.prototype.castRays = function(antialiasing) {
    var camera, h, w, _i, _results,
      _this = this;
    camera = this.scene.camera;
    w = camera.width * antialiasing;
    h = camera.height * antialiasing;
    return (function() {
      _results = [];
      for (var _i = 1; 1 <= antialiasing ? _i <= antialiasing : _i >= antialiasing; 1 <= antialiasing ? _i++ : _i--){ _results.push(_i); }
      return _results;
    }).apply(this).map(function(i) {
      var _i, _results;
      return (function() {
        _results = [];
        for (var _i = 1; 1 <= antialiasing ? _i <= antialiasing : _i >= antialiasing; 1 <= antialiasing ? _i++ : _i--){ _results.push(_i); }
        return _results;
      }).apply(this).map(function(j) {
        var centerPixelX, centerPixelY, rayDirection;
        centerPixelX = (_this.pixelX * antialiasing + (i - 1) + 0.5 - w / 2) / h * camera.imagePaneHeight;
        centerPixelY = (-_this.pixelY * antialiasing - (j - 1) - 0.5 + h / 2) / w * camera.imagePaneWidth;
        rayDirection = camera.imageCenter.add(camera.upDirection.multiply(centerPixelX)).add(camera.rightDirection.multiply(centerPixelY)).subtract(camera.position);
        return new Ray($L(camera.position, rayDirection), 1, 1);
      });
    }).reduce(function(a, b) {
      return a.concat(b);
    });
  };

  return RayTracer;

})();
