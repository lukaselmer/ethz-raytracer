// Generated by CoffeeScript 1.6.3
var Cylinder;

Cylinder = (function() {
  function Cylinder(axis_line, fixed_x, fixed_y, fixed_z, radius_x, radius_y, radius_z, reflectionProperties) {
    this.axis_line = axis_line;
    this.fixed_x = fixed_x;
    this.fixed_y = fixed_y;
    this.fixed_z = fixed_z;
    this.radius_x = radius_x;
    this.radius_y = radius_y;
    this.radius_z = radius_z;
    this.reflectionProperties = reflectionProperties;
    this.radius_x_2 = Math.square(this.radius_x);
    this.radius_z_2 = Math.square(this.radius_z);
    /*
    @radius_x_2 = Math.square(@radius_x)
    @radius_y_2 = Math.square(@radius_y)
    @radius_z_2 = Math.square(@radius_z)
    */

  }

  Cylinder.prototype.norm = function(intersectionPoint) {
    /*
    int = $V([((if @fixed_x then 0 else intersectionPoint.e(1))),
              ((if @fixed_y then 0 else intersectionPoint.e(2))),
              ((if @fixed_z then 0 else intersectionPoint.e(3)))])
    normal = int.subtract(@axis_line)
    normal.toUnitVector()
    */

  };

  Cylinder.prototype.intersects = function(ray) {
    return null;
    /*
    oc = ray.line.anchor.subtract(@axis_line)
    dir = ray.line.direction.toUnitVector()
    
    a = ((if @fixed_x then 0 else ((dir.e(1) * dir.e(1)) / @radius_x_2))) +
    ((if @fixed_y then 0 else (dir.e(2) * dir.e(2) / @radius_y_2))) +
    ((if @fixed_z then 0 else dir.e(3) * dir.e(3) / @radius_z_2))
    
    b = ((if @fixed_x then 0 else ((2 * oc.e(1) * dir.e(1)) / @radius_x_2))) +
    ((if @fixed_y then 0 else ((2 * oc.e(2) * dir.e(2)) / @radius_y_2))) +
    ((if @fixed_z then 0 else ((2 * oc.e(3) * dir.e(3)) / @radius_z_2)))
    
    c = ((if @fixed_x then 0 else ((oc.e(1) * oc.e(1)) / @radius_x_2))) +
    ((if @fixed_y then 0 else ((oc.e(2) * oc.e(2)) / @radius_y_2))) +
    ((if @fixed_z then 0 else ((oc.e(3) * oc.e(3)) / @radius_z_2))) - 1
    
    under_root = (Math.square(b) - (4.0 * a * c))
    return null if under_root < 0 || a == 0 || b == 0 || c == 0
    
    root = Math.sqrt(under_root)
    t1 = (-b + root) / (2 * a)
    t2 = (-b - root) / (2 * a)
    return t2  if t1 < RayConfig.intersectionDelta
    return t1  if t2 < RayConfig.intersectionDelta
    Math.min t1, t2
    */

  };

  return Cylinder;

})();
