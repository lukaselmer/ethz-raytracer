// Generated by CoffeeScript 1.6.3
/* Random log*/


(function() {
  var Camera, Color, Light, LightIntensity, Ray, RayTracer, ReflectionProperty, Scene, Sphere;

  console.setRlog = function(p) {
    if (p == null) {
      p = 0.0001;
    }
    return this.shoulLog = Math.random() <= p;
  };

  console.rlog = function(msg) {
    if (!this.shoulLog) {
      return;
    }
    return console.log(msg);
  };

  Color = (function() {
    function Color(r, g, b) {
      this.val = $V([r, g, b]);
    }

    Color.prototype.toArray = function() {
      return [this.val.elements[0], this.val.elements[1], this.val.elements[2]];
    };

    Color.prototype.add = function(color) {
      var v;
      color.val;
      v = this.val.add(color.val);
      return new Color(v.elements[0], v.elements[1], v.elements[2]);
    };

    return Color;

  })();

  Scene = (function() {
    function Scene(camera, light) {
      this.camera = camera;
      this.light = light;
      this.objects = [];
    }

    Scene.prototype.addObject = function(object) {
      return this.objects[this.objects.length] = object;
    };

    Scene.prototype.intersections = function(ray) {
      var object, _i, _len, _ref, _results;
      _ref = this.objects;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        object = _ref[_i];
        if (object.intersects(ray)) {
          _results.push(object);
        }
      }
      return _results;
    };

    return Scene;

  })();

  Camera = (function() {
    function Camera(position, direction, upDirection, fieldOfView, width, height) {
      this.position = position;
      this.direction = direction;
      this.upDirection = upDirection;
      this.fieldOfView = fieldOfView;
      this.width = width;
      this.height = height;
      this.calibrateCamera();
    }

    Camera.prototype.calibrateCamera = function() {
      this.direction = this.direction.toUnitVector();
      this.rightDirection = this.direction.cross(this.upDirection).toUnitVector();
      return this.upDirection = this.rightDirection.cross(this.direction).toUnitVector();
    };

    Camera.prototype.getCenter = function() {
      return this.position.add(this.direction);
    };

    return Camera;

  })();

  Light = (function() {
    function Light(color, location, intensity) {
      this.color = color;
      this.location = location;
      this.intensity = intensity;
    }

    return Light;

  })();

  LightIntensity = (function() {
    function LightIntensity(ambient, diffuse, specular, globalAmbient) {
      this.ambient = ambient;
      this.diffuse = diffuse;
      this.specular = specular;
      this.globalAmbient = globalAmbient;
    }

    return LightIntensity;

  })();

  ReflectionProperty = (function() {
    function ReflectionProperty(ambientColor, diffuseColor, specularColor, specularExponent) {
      this.ambientColor = ambientColor;
      this.diffuseColor = diffuseColor;
      this.specularColor = specularColor;
      this.specularExponent = specularExponent;
    }

    return ReflectionProperty;

  })();

  Sphere = (function() {
    function Sphere(center, radius, reflectionProperties) {
      this.center = center;
      this.radius = radius;
      this.reflectionProperties = reflectionProperties;
      this.radiusSquared = this.radius * this.radius;
    }

    Sphere.prototype.intersects = function(ray) {
      var c, c_minus_o, d, distSquared, o, r, rayDistanceClosestToCenter, shortestDistanceFromCenterToRaySquared, t, x;
      console.setRlog();
      console.rlog("");
      o = ray.line.anchor;
      d = ray.line.direction;
      c = this.center;
      r = this.radius;
      c_minus_o = c.subtract(o);
      distSquared = c_minus_o.dot(c_minus_o);
      console.rlog("distSquared=" + distSquared);
      rayDistanceClosestToCenter = c_minus_o.dot(d);
      console.rlog("rayDistanceClosestToCenter=" + rayDistanceClosestToCenter);
      if (rayDistanceClosestToCenter < 0) {
        return false;
      }
      shortestDistanceFromCenterToRaySquared = distSquared - (rayDistanceClosestToCenter * rayDistanceClosestToCenter);
      console.rlog("shortestDistanceFromCenterToRay=" + shortestDistanceFromCenterToRaySquared);
      console.rlog("@radiusSquared=" + this.radiusSquared);
      if (shortestDistanceFromCenterToRaySquared > this.radiusSquared) {
        return false;
      }
      x = this.radiusSquared - shortestDistanceFromCenterToRaySquared;
      t = rayDistanceClosestToCenter - Math.sqrt(x);
      console.rlog("halfChordDistance=" + t);
      console.rlog(ray.line);
      return true;
    };

    return Sphere;

  })();

  Ray = (function() {
    function Ray(line) {
      this.line = line;
    }

    return Ray;

  })();

  RayTracer = (function() {
    function RayTracer(color, pixelX, pixelY, scene) {
      this.color = color;
      this.pixelX = pixelX;
      this.pixelY = pixelY;
      this.scene = scene;
    }

    RayTracer.prototype.trace = function() {
      var c, intersections, ray;
      ray = this.castRay();
      intersections = this.scene.intersections(ray);
      c = new Color(0, 0, 0);
      if (intersections.length === 0) {
        console.rlog(intersections);
      }
      if (intersections.length === 1) {
        console.rlog(intersections);
        c = c.add(intersections[0].reflectionProperties.ambientColor);
      }
      if (intersections.length === 2) {
        console.rlog(intersections);
        c = c.add(intersections[1].reflectionProperties.ambientColor);
      }
      return this.color.setElements(c.toArray());
    };

    RayTracer.prototype.castRay = function() {
      var camera, centerPixelX, centerPixelY, height, rayDirection, width, _ref, _ref1;
      camera = scene.camera;
      _ref = [camera.width, camera.height], width = _ref[0], height = _ref[1];
      _ref1 = [(this.pixelX / width) - 0.5, (this.pixelY / height) - 0.5], centerPixelX = _ref1[0], centerPixelY = _ref1[1];
      rayDirection = camera.rightDirection.multiply(centerPixelX).add(camera.upDirection.multiply(centerPixelY)).add(camera.direction);
      return new Ray($L(scene.camera.position, rayDirection.toUnitVector()));
    };

    return RayTracer;

  })();

  this.loadScene = function() {
    var camera, light, scene;
    camera = new Camera($V([0, 0, 10]), $V([0, 0, -1]), $V([0, 1, 0]), 40, 800, 600);
    light = new Light(new Color(1, 1, 1), $V([10, 10, 10]), new LightIntensity(0, 1, 1, 0.2));
    scene = new Scene(camera, light);
    scene.addObject(new Sphere($V([0, 0, 0]), 2, new ReflectionProperty(new Color(0.75, 0, 0), new Color(1, 0, 0), new Color(1, 1, 1), 32)));
    scene.addObject(new Sphere($V([1.25, 1.25, 3]), 0.5, new ReflectionProperty(new Color(0, 0, 0.75), new Color(0, 0, 1), new Color(0.5, 0.5, 1), 16)));
    return this.scene = scene;
  };

  this.trace = function(color, pixelX, pixelY) {
    var rayTracer;
    rayTracer = new RayTracer(color, pixelX, pixelY, scene);
    return rayTracer.trace();
  };

}).call(this);

/*
//@ sourceMappingURL=raytracer.map
*/
