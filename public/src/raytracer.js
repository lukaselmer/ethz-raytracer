// Generated by CoffeeScript 1.6.3
(function() {
  var Camera, Color, Light, LightIntensity, Ray, RayTracer, ReflectionProperty, Scene, Sphere;

  Color = (function() {
    function Color(r, g, b) {
      if (r < 0) {
        r = 0;
      }
      if (g < 0) {
        g = 0;
      }
      if (b < 0) {
        b = 0;
      }
      if (r > 1) {
        r = 1;
      }
      if (g > 1) {
        g = 1;
      }
      if (b > 1) {
        b = 1;
      }
      this.val = $V([r, g, b]);
    }

    Color.prototype.toArray = function() {
      return [this.val.elements[0], this.val.elements[1], this.val.elements[2]];
    };

    Color.prototype.add = function(color) {
      var v;
      color.val;
      v = this.val.add(color.val);
      return new Color(v.elements[0], v.elements[1], v.elements[2]);
    };

    Color.prototype.multiply = function(scale) {
      return new Color(this.val.elements[0] * scale, this.val.elements[1] * scale, this.val.elements[2] * scale);
    };

    return Color;

  })();

  Scene = (function() {
    function Scene(camera, light) {
      this.camera = camera;
      this.light = light;
      this.objects = [];
    }

    Scene.prototype.addObject = function(object) {
      return this.objects[this.objects.length] = object;
    };

    Scene.prototype.intersections = function(ray) {
      var object, _i, _len, _ref, _results;
      _ref = this.objects;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        object = _ref[_i];
        if (object.intersects(ray)) {
          _results.push(object);
        }
      }
      return _results;
    };

    Scene.prototype.firstIntersection = function(ray) {
      var min, ret;
      min = Infinity;
      ret = null;
      this.objects.forEach(function(object) {
        var i, intersectionPoint;
        i = object.intersects(ray);
        if (i && i < min) {
          min = i;
          intersectionPoint = ray.line.anchor.add(ray.line.direction.multiply(i));
          return ret = [intersectionPoint, object];
        }
      });
      return ret;
    };

    return Scene;

  })();

  Camera = (function() {
    function Camera(position, direction, upDirection, distance, fieldOfView, width, height) {
      this.position = position;
      this.direction = direction;
      this.upDirection = upDirection;
      this.distance = distance;
      this.fieldOfView = fieldOfView;
      this.width = width;
      this.height = height;
      this.calibrateCamera();
    }

    Camera.prototype.calibrateCamera = function() {
      this.direction = this.direction.toUnitVector();
      this.rightDirection = this.direction.cross(this.upDirection).toUnitVector();
      this.upDirection = this.rightDirection.cross(this.direction).toUnitVector();
      this.imagePaneHeight = 2 * Math.tan(this.fieldOfView / 2) * this.distance;
      this.imagePaneWidth = this.imagePaneHeight / this.height * this.width;
      this.imageCenter = this.position.add(this.direction.multiply(this.distance));
      this.imageTop = this.imageCenter.add(this.upDirection.multiply(this.imagePaneHeight / 2));
      this.imageBottom = this.imageCenter.add(this.upDirection.multiply(-1 * this.imagePaneHeight / 2));
      this.imageLeft = this.imageCenter.add(this.rightDirection.multiply(-1 * this.imagePaneWidth / 2));
      return this.imageRight = this.imageCenter.add(this.rightDirection.multiply(this.imagePaneWidth / 2));
    };

    Camera.prototype.getCenter = function() {
      return this.position.add(this.direction);
    };

    return Camera;

  })();

  Light = (function() {
    function Light(color, location, intensity) {
      this.color = color;
      this.location = location;
      this.intensity = intensity;
    }

    return Light;

  })();

  LightIntensity = (function() {
    function LightIntensity(ambient, diffuse, specular, globalAmbient) {
      this.ambient = ambient;
      this.diffuse = diffuse;
      this.specular = specular;
      this.globalAmbient = globalAmbient;
    }

    return LightIntensity;

  })();

  ReflectionProperty = (function() {
    function ReflectionProperty(ambientColor, diffuseColor, specularColor, specularExponent) {
      this.ambientColor = ambientColor;
      this.diffuseColor = diffuseColor;
      this.specularColor = specularColor;
      this.specularExponent = specularExponent;
    }

    return ReflectionProperty;

  })();

  Sphere = (function() {
    function Sphere(center, radius, reflectionProperties) {
      this.center = center;
      this.radius = radius;
      this.reflectionProperties = reflectionProperties;
      this.radiusSquared = this.radius * this.radius;
    }

    Sphere.prototype.norm = function(intersectionPoint) {
      return intersectionPoint.subtract(this.center).toUnitVector();
    };

    Sphere.prototype.intersects = function(ray) {
      var c, c_minus_o, d, distSquared, o, rayDistanceClosestToCenter, shortestDistanceFromCenterToRaySquared, t, x;
      console.setRlog();
      console.rlog("");
      o = ray.line.anchor;
      d = ray.line.direction;
      c = this.center;
      c_minus_o = c.subtract(o);
      console.rlog("c_minus_o:");
      console.rlog(c_minus_o);
      distSquared = c_minus_o.dot(c_minus_o);
      console.rlog("distSquared=" + distSquared);
      rayDistanceClosestToCenter = c_minus_o.dot(d);
      console.rlog("rayDistanceClosestToCenter=" + rayDistanceClosestToCenter);
      if (rayDistanceClosestToCenter < 0) {
        return false;
      }
      shortestDistanceFromCenterToRaySquared = distSquared - (rayDistanceClosestToCenter * rayDistanceClosestToCenter);
      console.rlog("shortestDistanceFromCenterToRay=" + shortestDistanceFromCenterToRaySquared);
      console.rlog("@radiusSquared=" + this.radiusSquared);
      if (shortestDistanceFromCenterToRaySquared > this.radiusSquared) {
        return false;
      }
      x = this.radiusSquared - shortestDistanceFromCenterToRaySquared;
      if (x < 0) {
        return false;
      }
      t = rayDistanceClosestToCenter - Math.sqrt(x);
      console.rlog("halfChordDistance=" + t);
      return t;
    };

    return Sphere;

  })();

  Ray = (function() {
    function Ray(line) {
      this.line = line;
    }

    return Ray;

  })();

  RayTracer = (function() {
    function RayTracer(color, pixelX, pixelY, scene) {
      this.color = color;
      this.pixelX = pixelX;
      this.pixelY = pixelY;
      this.scene = scene;
    }

    RayTracer.prototype.trace = function() {
      var c, intersection, obj, pos, ray;
      ray = this.castRay();
      intersection = this.scene.firstIntersection(ray);
      c = new Color(0, 0, 0);
      if (intersection) {
        console.rlog(intersection[1]);
        pos = intersection[0];
        obj = intersection[1];
        c = this.illuminate(pos, obj, ray);
      }
      return this.color.setElements(c.toArray());
    };

    RayTracer.prototype.illuminate = function(pos, obj, ray) {
      var E, ambient, ambientColor, diffuse, frac, globalAmbient, globalAmbientColor, kd, ks, n, nv, specularHighlights, spepcularIntensity, w, wl, wr;
      nv = obj.norm(pos);
      w = ray.line.direction;
      wl = this.scene.light.location.subtract(pos).toUnitVector();
      wr = nv.multiply(2).multiply(w.dot(nv)).subtract(w);
      globalAmbient = this.scene.light.intensity.globalAmbient;
      globalAmbientColor = obj.reflectionProperties.ambientColor.multiply(globalAmbient);
      ambient = this.scene.light.intensity.ambient;
      ambientColor = obj.reflectionProperties.ambientColor.multiply(ambient);
      kd = obj.reflectionProperties.diffuseColor;
      E = this.scene.light.intensity.diffuse * nv.dot(wl);
      diffuse = kd.multiply(E * this.scene.light.intensity.diffuse);
      n = obj.reflectionProperties.specularExponent;
      ks = obj.reflectionProperties.specularColor;
      frac = Math.pow(wr.dot(wl), n) / nv.dot(wl);
      spepcularIntensity = frac * E;
      if (frac < 0) {
        spepcularIntensity = 0;
      }
      specularHighlights = ks.multiply(spepcularIntensity);
      return globalAmbientColor.add(ambientColor).add(diffuse).add(specularHighlights);
    };

    RayTracer.prototype.castRay = function() {
      var camera, centerPixelX, centerPixelY, rayDirection;
      camera = scene.camera;
      centerPixelX = (this.pixelX + 0.5 - camera.width / 2) / camera.height * camera.imagePaneHeight;
      centerPixelY = (-this.pixelY - 0.5 + camera.height / 2) / camera.width * camera.imagePaneWidth;
      rayDirection = camera.imageCenter.add(camera.upDirection.multiply(centerPixelX)).add(camera.rightDirection.multiply(centerPixelY)).subtract(camera.position);
      return new Ray($L(camera.position, rayDirection));
    };

    return RayTracer;

  })();

  this.loadScene = function() {
    var camera, fieldOfView, light, scene;
    fieldOfView = 40 / 180 * Math.PI;
    camera = new Camera($V([0, 0, 10]), $V([0, 0, -1]), $V([0, 1, 0]), 1, fieldOfView, 800, 600);
    light = new Light(new Color(1, 1, 1), $V([10, 10, 10]), new LightIntensity(0, 1, 1, 0.2));
    scene = new Scene(camera, light);
    scene.addObject(new Sphere($V([0, 0, 0]), 2, new ReflectionProperty(new Color(0.75, 0, 0), new Color(1, 0, 0), new Color(1, 1, 1), 32)));
    scene.addObject(new Sphere($V([1.25, 1.25, 3]), 0.5, new ReflectionProperty(new Color(0, 0, 0.75), new Color(0, 0, 1), new Color(0.5, 0.5, 1), 16)));
    return this.scene = scene;
  };

  this.trace = function(color, pixelX, pixelY) {
    var rayTracer;
    rayTracer = new RayTracer(color, pixelX, pixelY, scene);
    return rayTracer.trace();
  };

}).call(this);

/*
//@ sourceMappingURL=raytracer.map
*/
